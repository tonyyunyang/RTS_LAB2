
SchedTest.elf:     file format elf32-msp430

SYMBOL TABLE:
00004000 l    d  .text	00000000 .text
00001100 l    d  .bss	00000000 .bss
0000ffe0 l    d  .vectors	00000000 .vectors
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
000046fe l    d  .debug_ranges	00000000 .debug_ranges
00000130 l       *ABS*	00000000 MPY
00000132 l       *ABS*	00000000 MPYS
00000134 l       *ABS*	00000000 MAC
00000136 l       *ABS*	00000000 MACS
00000138 l       *ABS*	00000000 OP2
0000013a l       *ABS*	00000000 RESLO
0000013c l       *ABS*	00000000 RESHI
0000013e l       *ABS*	00000000 SUMEXT
00000020 l       *ABS*	00000000 P1IN
00000021 l       *ABS*	00000000 P1OUT
00000022 l       *ABS*	00000000 P1DIR
00000023 l       *ABS*	00000000 P1IFG
00000024 l       *ABS*	00000000 P1IES
00000025 l       *ABS*	00000000 P1IE
00000026 l       *ABS*	00000000 P1SEL
00000028 l       *ABS*	00000000 P2IN
00000029 l       *ABS*	00000000 P2OUT
0000002a l       *ABS*	00000000 P2DIR
0000002b l       *ABS*	00000000 P2IFG
0000002c l       *ABS*	00000000 P2IES
0000002d l       *ABS*	00000000 P2IE
0000002e l       *ABS*	00000000 P2SEL
00000018 l       *ABS*	00000000 P3IN
00000019 l       *ABS*	00000000 P3OUT
0000001a l       *ABS*	00000000 P3DIR
0000001b l       *ABS*	00000000 P3SEL
0000001c l       *ABS*	00000000 P4IN
0000001d l       *ABS*	00000000 P4OUT
0000001e l       *ABS*	00000000 P4DIR
0000001f l       *ABS*	00000000 P4SEL
00000030 l       *ABS*	00000000 P5IN
00000031 l       *ABS*	00000000 P5OUT
00000032 l       *ABS*	00000000 P5DIR
00000033 l       *ABS*	00000000 P5SEL
00000034 l       *ABS*	00000000 P6IN
00000035 l       *ABS*	00000000 P6OUT
00000036 l       *ABS*	00000000 P6DIR
00000037 l       *ABS*	00000000 P6SEL
00000070 l       *ABS*	00000000 U0CTL
00000071 l       *ABS*	00000000 U0TCTL
00000072 l       *ABS*	00000000 U0RCTL
00000073 l       *ABS*	00000000 U0MCTL
00000074 l       *ABS*	00000000 U0BR0
00000075 l       *ABS*	00000000 U0BR1
00000076 l       *ABS*	00000000 U0RXBUF
00000077 l       *ABS*	00000000 U0TXBUF
00000070 l       *ABS*	00000000 UCTL
00000071 l       *ABS*	00000000 UTCTL
00000072 l       *ABS*	00000000 URCTL
00000073 l       *ABS*	00000000 UMCTL
00000074 l       *ABS*	00000000 UBR0
00000075 l       *ABS*	00000000 UBR1
00000076 l       *ABS*	00000000 RXBUF
00000077 l       *ABS*	00000000 TXBUF
00000070 l       *ABS*	00000000 UCTL0
00000071 l       *ABS*	00000000 UTCTL0
00000072 l       *ABS*	00000000 URCTL0
00000073 l       *ABS*	00000000 UMCTL0
00000074 l       *ABS*	00000000 UBR00
00000075 l       *ABS*	00000000 UBR10
00000076 l       *ABS*	00000000 RXBUF0
00000077 l       *ABS*	00000000 TXBUF0
00000070 l       *ABS*	00000000 UCTL_0
00000071 l       *ABS*	00000000 UTCTL_0
00000072 l       *ABS*	00000000 URCTL_0
00000073 l       *ABS*	00000000 UMCTL_0
00000074 l       *ABS*	00000000 UBR0_0
00000075 l       *ABS*	00000000 UBR1_0
00000076 l       *ABS*	00000000 RXBUF_0
00000077 l       *ABS*	00000000 TXBUF_0
00000050 l       *ABS*	00000000 I2CIE
00000051 l       *ABS*	00000000 I2CIFG
00000052 l       *ABS*	00000000 I2CNDAT
00000071 l       *ABS*	00000000 I2CTCTL
00000072 l       *ABS*	00000000 I2CDCTL
00000073 l       *ABS*	00000000 I2CPSC
00000074 l       *ABS*	00000000 I2CSCLH
00000075 l       *ABS*	00000000 I2CSCLL
00000076 l       *ABS*	00000000 I2CDRB
00000076 l       *ABS*	00000000 I2CDRW
00000118 l       *ABS*	00000000 I2COA
0000011a l       *ABS*	00000000 I2CSA
0000011c l       *ABS*	00000000 I2CIV
00000076 l       *ABS*	00000000 I2CDR
00000078 l       *ABS*	00000000 U1CTL
00000079 l       *ABS*	00000000 U1TCTL
0000007a l       *ABS*	00000000 U1RCTL
0000007b l       *ABS*	00000000 U1MCTL
0000007c l       *ABS*	00000000 U1BR0
0000007d l       *ABS*	00000000 U1BR1
0000007e l       *ABS*	00000000 U1RXBUF
0000007f l       *ABS*	00000000 U1TXBUF
00000078 l       *ABS*	00000000 UCTL1
00000079 l       *ABS*	00000000 UTCTL1
0000007a l       *ABS*	00000000 URCTL1
0000007b l       *ABS*	00000000 UMCTL1
0000007c l       *ABS*	00000000 UBR01
0000007d l       *ABS*	00000000 UBR11
0000007e l       *ABS*	00000000 RXBUF1
0000007f l       *ABS*	00000000 TXBUF1
00000078 l       *ABS*	00000000 UCTL_1
00000079 l       *ABS*	00000000 UTCTL_1
0000007a l       *ABS*	00000000 URCTL_1
0000007b l       *ABS*	00000000 UMCTL_1
0000007c l       *ABS*	00000000 UBR0_1
0000007d l       *ABS*	00000000 UBR1_1
0000007e l       *ABS*	00000000 RXBUF_1
0000007f l       *ABS*	00000000 TXBUF_1
00000055 l       *ABS*	00000000 SVSCTL
00000128 l       *ABS*	00000000 FCTL1
0000012a l       *ABS*	00000000 FCTL2
0000012c l       *ABS*	00000000 FCTL3
00000059 l       *ABS*	00000000 CACTL1
0000005a l       *ABS*	00000000 CACTL2
0000005b l       *ABS*	00000000 CAPD
0000012e l       *ABS*	00000000 TA0IV
00000160 l       *ABS*	00000000 TA0CTL
00000170 l       *ABS*	00000000 TA0R
00000162 l       *ABS*	00000000 TA0CCTL0
00000164 l       *ABS*	00000000 TA0CCTL1
00000172 l       *ABS*	00000000 TA0CCR0
00000174 l       *ABS*	00000000 TA0CCR1
00000166 l       *ABS*	00000000 TA0CCTL2
00000176 l       *ABS*	00000000 TA0CCR2
0000011e l       *ABS*	00000000 TBIV
00000180 l       *ABS*	00000000 TBCTL
00000190 l       *ABS*	00000000 TBR
00000182 l       *ABS*	00000000 TBCCTL0
00000184 l       *ABS*	00000000 TBCCTL1
00000186 l       *ABS*	00000000 TBCCTL2
00000192 l       *ABS*	00000000 TBCCR0
00000194 l       *ABS*	00000000 TBCCR1
00000196 l       *ABS*	00000000 TBCCR2
00000188 l       *ABS*	00000000 TBCCTL3
0000018a l       *ABS*	00000000 TBCCTL4
0000018c l       *ABS*	00000000 TBCCTL5
0000018e l       *ABS*	00000000 TBCCTL6
00000198 l       *ABS*	00000000 TBCCR3
0000019a l       *ABS*	00000000 TBCCR4
0000019c l       *ABS*	00000000 TBCCR5
0000019e l       *ABS*	00000000 TBCCR6
00000056 l       *ABS*	00000000 DCOCTL
00000057 l       *ABS*	00000000 BCSCTL1
00000058 l       *ABS*	00000000 BCSCTL2
000001a0 l       *ABS*	00000000 ADC12CTL0
000001a2 l       *ABS*	00000000 ADC12CTL1
000001a4 l       *ABS*	00000000 ADC12IFG
000001a6 l       *ABS*	00000000 ADC12IE
000001a8 l       *ABS*	00000000 ADC12IV
00000140 l       *ABS*	00000000 ADC12MEM0
00000142 l       *ABS*	00000000 ADC12MEM1
00000144 l       *ABS*	00000000 ADC12MEM2
00000146 l       *ABS*	00000000 ADC12MEM3
00000148 l       *ABS*	00000000 ADC12MEM4
0000014a l       *ABS*	00000000 ADC12MEM5
0000014c l       *ABS*	00000000 ADC12MEM6
0000014e l       *ABS*	00000000 ADC12MEM7
00000150 l       *ABS*	00000000 ADC12MEM8
00000152 l       *ABS*	00000000 ADC12MEM9
00000154 l       *ABS*	00000000 ADC12MEM10
00000156 l       *ABS*	00000000 ADC12MEM11
00000158 l       *ABS*	00000000 ADC12MEM12
0000015a l       *ABS*	00000000 ADC12MEM13
0000015c l       *ABS*	00000000 ADC12MEM14
0000015e l       *ABS*	00000000 ADC12MEM15
00000080 l       *ABS*	00000000 ADC12MCTL0
00000081 l       *ABS*	00000000 ADC12MCTL1
00000082 l       *ABS*	00000000 ADC12MCTL2
00000083 l       *ABS*	00000000 ADC12MCTL3
00000084 l       *ABS*	00000000 ADC12MCTL4
00000085 l       *ABS*	00000000 ADC12MCTL5
00000086 l       *ABS*	00000000 ADC12MCTL6
00000087 l       *ABS*	00000000 ADC12MCTL7
00000088 l       *ABS*	00000000 ADC12MCTL8
00000089 l       *ABS*	00000000 ADC12MCTL9
0000008a l       *ABS*	00000000 ADC12MCTL10
0000008b l       *ABS*	00000000 ADC12MCTL11
0000008c l       *ABS*	00000000 ADC12MCTL12
0000008d l       *ABS*	00000000 ADC12MCTL13
0000008e l       *ABS*	00000000 ADC12MCTL14
0000008f l       *ABS*	00000000 ADC12MCTL15
000001c0 l       *ABS*	00000000 DAC12_0CTL
000001c2 l       *ABS*	00000000 DAC12_1CTL
000001c8 l       *ABS*	00000000 DAC12_0DAT
000001ca l       *ABS*	00000000 DAC12_1DAT
00000122 l       *ABS*	00000000 DMACTL0
00000124 l       *ABS*	00000000 DMACTL1
000001e0 l       *ABS*	00000000 DMA0CTL
000001e2 l       *ABS*	00000000 DMA0SA
000001e4 l       *ABS*	00000000 DMA0DA
000001e6 l       *ABS*	00000000 DMA0SZ
000001e8 l       *ABS*	00000000 DMA1CTL
000001ea l       *ABS*	00000000 DMA1SA
000001ec l       *ABS*	00000000 DMA1DA
000001ee l       *ABS*	00000000 DMA1SZ
000001f0 l       *ABS*	00000000 DMA2CTL
000001f2 l       *ABS*	00000000 DMA2SA
000001f4 l       *ABS*	00000000 DMA2DA
000001f6 l       *ABS*	00000000 DMA2SZ
00000120 l       *ABS*	00000000 WDTCTL
00000000 l       *ABS*	00000000 IE1
00000002 l       *ABS*	00000000 IFG1
00000001 l       *ABS*	00000000 IE2
00000003 l       *ABS*	00000000 IFG2
00000004 l       *ABS*	00000000 ME1
00000005 l       *ABS*	00000000 ME2
00000000 l    df *ABS*	00000000 SchedTest.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Led.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Clock.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Context.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001100 l     O .bss	00000001 CurrentContext
00001102 l     O .bss	00000003 Contexts
00000000 l    df *ABS*	00000000 SchedulerOnline.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Scheduler_P_FP.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 Scheduler_P_EDF.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00000000 l    df *ABS*	00000000 TimeTracking.c
00000130 l       *ABS*	00000000 __MPY
00000132 l       *ABS*	00000000 __MPYS
00000134 l       *ABS*	00000000 __MAC
00000136 l       *ABS*	00000000 __MACS
00000138 l       *ABS*	00000000 __OP2
0000013a l       *ABS*	00000000 __RESLO
0000013c l       *ABS*	00000000 __RESHI
0000013e l       *ABS*	00000000 __SUMEXT
00001106 l     O .bss	00000004 StartTimes
0000110a l     O .bss	00000004 Totals
0000110e l     O .bss	00000001 JobsExecuted
00000000 g       *ABS*	00000000 __data_size
000042ce g     F .text	00000084 RegisterTask
00004282 g     F .text	00000016 ResumeContext
00004252 g     F .text	00000018 InitClock
00004658 g     F .text	0000000c StartTracking
000046e2 g       .text	00000000 __udivmodhi4
00004232 g     F .text	0000000a InitLeds
00004036 g     F .text	00000018 CountDelay
000046fe g       .text	00000000 _etext
000000b4 g       *ABS*	00000000 __bss_size
0000467a g     F .text	00000006 AddJobExecution
00004030 g       .text	00000000 _unexpected_1_
00004030  w      .text	00000000 vector_ffe0
00001110 g     O .bss	00000001 BusyPrio
0000447e g     F .text	00000062 Scheduler_P_FP
000044e0 g     F .text	00000178 Scheduler_P_EDF
000043ca g       .text	00000000 vector_ffec
00004030  w      .text	00000000 vector_fff0
000046fe g       *ABS*	00000000 __data_load_start
00004030 g       .text	00000000 __dtors_end
00004030  w      .text	00000000 vector_fffc
000041f6 g     F .text	0000003c BlinkYellow
00004030  w      .text	00000000 vector_ffe4
0000424c g     F .text	00000006 ToggleLeds
0000423c g     F .text	00000010 SetLeds
0000ffe0 g     O .vectors	00000020 InterruptVectors
00004352 g     F .text	00000014 UnRegisterTask
00001111 g     O .bss	00000001 Pending
0000426a g     F .text	00000018 ContextSwitch
000041ba g     F .text	0000003c BlinkGreen
0000401c  w      .text	00000000 __do_clear_bss
000043ca g     F .text	000000b4 TimerIntrpt
00004030  w      .text	00000000 vector_ffe2
00004030  w      .text	00000000 vector_ffe8
00004034  w      .text	00000000 _unexpected_
000046ac g       .text	00000000 __divmodhi4
00004030  w      .text	00000000 vector_fffa
00001112 g     O .bss	000000a0 Tasks
00004000  w      .text	00000000 _reset_vector__
00004030 g       .text	00000000 __ctors_start
0000400a  w      .text	00000000 __do_copy_data
0000404e g     F .text	00000020 CountRealtimeDelay
00001100 g       .bss	00000000 __bss_start
00004030  w      .text	00000000 vector_ffee
00004030  w      .text	00000000 vector_fff4
0000406e g     F .text	00000110 main
00004030  w      .text	00000000 vector_fff8
00004680 g     F .text	0000002c PrintResults
00004030  w      .text	00000000 vector_fff2
0000417e g     F .text	0000003c BlinkRed
00010000 g       .vectors	00000000 _vectors_end
00004030  w      .text	00000000 vector_ffe6
00004298 g     F .text	00000006 IntDisable
000011b2 g     O .bss	00000002 NextInterruptTime
00004000  w      .text	00000000 __init_stack
00004386 g     F .text	00000044 lcm
00004030 g       .text	00000000 __dtors_start
00004030 g       .text	00000000 __ctors_end
00003900 g       *ABS*	00000000 __stack
00001100 g       .bss	00000000 _edata
000011b4 g       .bss	00000000 _end
00004030  w      .text	00000000 vector_fff6
00004366 g     F .text	00000020 gcd
00004004  w      .text	00000000 __low_level_init
0000402c  w      .text	00000000 __jump_to_main
000042a2 g     F .text	0000002c InitTasks
00001100 g       .bss	00000000 __data_start
00004030  w      .text	00000000 vector_ffea
00004664 g     F .text	00000016 StopTracking
0000429e g     F .text	00000004 RestoreSW



Disassembly of section .text:

00004000 <__init_stack>:
    4000:	31 40 00 39 	mov	#14592,	r1	;#0x3900

00004004 <__low_level_init>:
    4004:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    4008:	20 01 

0000400a <__do_copy_data>:
    400a:	3f 40 00 00 	mov	#0,	r15	;#0x0000
    400e:	0f 93       	tst	r15		
    4010:	05 24       	jz	$+12     	;abs 0x401c
    4012:	2f 83       	decd	r15		
    4014:	9f 4f fe 46 	mov	18174(r15),4352(r15);0x46fe(r15), 0x1100(r15)
    4018:	00 11 
    401a:	fb 23       	jnz	$-8      	;abs 0x4012

0000401c <__do_clear_bss>:
    401c:	3f 40 b4 00 	mov	#180,	r15	;#0x00b4
    4020:	0f 93       	tst	r15		
    4022:	04 24       	jz	$+10     	;abs 0x402c
    4024:	1f 83       	dec	r15		
    4026:	cf 43 00 11 	mov.b	#0,	4352(r15);r3 As==00, 0x1100(r15)
    402a:	fc 23       	jnz	$-6      	;abs 0x4024

0000402c <__jump_to_main>:
    402c:	30 40 6e 40 	br	#0x406e	

00004030 <__ctors_end>:
    4030:	30 40 34 40 	br	#0x4034	

00004034 <_unexpected_>:
    4034:	00 13       	reti			

00004036 <CountDelay>:
#define YELLOWBLINKPRIO 0
#define GREENBLINKPRIO  1
#define REDBLINKPRIO    2

void CountDelay (volatile uint16_t cnt)
{
    4036:	21 83       	decd	r1		
    4038:	81 4f 00 00 	mov	r15,	0(r1)	;0x0000(r1)
  while (cnt--);
    403c:	2f 41       	mov	@r1,	r15	
    403e:	0e 4f       	mov	r15,	r14	
    4040:	3e 53       	add	#-1,	r14	;r3 As==11
    4042:	81 4e 00 00 	mov	r14,	0(r1)	;0x0000(r1)
    4046:	0f 93       	tst	r15		
    4048:	f9 23       	jnz	$-12     	;abs 0x403c
}
    404a:	21 53       	incd	r1		
    404c:	30 41       	ret			

0000404e <CountRealtimeDelay>:
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    404e:	0f 5f       	rla	r15		
    4050:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    4052:	1d 42 70 01 	mov	&0x0170,r13	
    4056:	0e 43       	clr	r14		
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4058:	07 3c       	jmp	$+16     	;abs 0x4068
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    405a:	1c 42 70 01 	mov	&0x0170,r12	
    405e:	0d 9c       	cmp	r12,	r13	
    4060:	fc 27       	jz	$-6      	;abs 0x405a
    {
      TicksPassed++; // increment ticks counter
    4062:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    4064:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4068:	0e 9f       	cmp	r15,	r14	
    406a:	f7 2b       	jnc	$-16     	;abs 0x405a
    {
      TicksPassed++; // increment ticks counter
      OldTAR = TAR; // store new value of TAR as old value
    }
  }
}
    406c:	30 41       	ret			

0000406e <main>:
  CountRealtimeDelay(ExecutionTime);
  SetLeds (RED, 0);
}

int main(void) 
{ 
    406e:	31 40 00 39 	mov	#14592,	r1	;#0x3900
  BusyPrio = NUMTASKS; // set the BusyPrio to a number greater than the largest task num
    4072:	f2 40 0a 00 	mov.b	#10,	&0x1110	;#0x000a
    4076:	10 11 

  WDTCTL = WDTPW + WDTHOLD;       // Stop watchdog timer 
    4078:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    407c:	20 01 
  
  InitClock ();
    407e:	b0 12 52 42 	call	#0x4252	

  InitLeds (RED | GREEN | YELLOW | WHITE | BROWN | PURPLE);
    4082:	7f 40 77 00 	mov.b	#119,	r15	;#0x0077
    4086:	b0 12 32 42 	call	#0x4232	
  RegisterTask (0, 1024, 150, BlinkRed, REDBLINKPRIO, 0);
#endif

#ifdef TstSweep
  // note: there 1024 ticks in second
  RegisterTask (0, 1024, 350, BlinkYellow, YELLOWBLINKPRIO, 0); 
    408a:	43 12       	push.b	#0		;r3 As==00
    408c:	43 12       	push.b	#0		;r3 As==00
    408e:	3c 40 f6 41 	mov	#16886,	r12	;#0x41f6
    4092:	3d 40 5e 01 	mov	#350,	r13	;#0x015e
    4096:	3e 40 00 04 	mov	#1024,	r14	;#0x0400
    409a:	0f 43       	clr	r15		
    409c:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 512, 140, BlinkGreen, GREENBLINKPRIO, 0);
    40a0:	43 12       	push.b	#0		;r3 As==00
    40a2:	53 12       	push.b	#1		;r3 As==01
    40a4:	3c 40 ba 41 	mov	#16826,	r12	;#0x41ba
    40a8:	3d 40 8c 00 	mov	#140,	r13	;#0x008c
    40ac:	3e 40 00 02 	mov	#512,	r14	;#0x0200
    40b0:	0f 43       	clr	r15		
    40b2:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 256, 30, BlinkRed, REDBLINKPRIO, 0);
    40b6:	43 12       	push.b	#0		;r3 As==00
    40b8:	63 12       	push.b	#2		;r3 As==10
    40ba:	3c 40 7e 41 	mov	#16766,	r12	;#0x417e
    40be:	3d 40 1e 00 	mov	#30,	r13	;#0x001e
    40c2:	3e 40 00 01 	mov	#256,	r14	;#0x0100
    40c6:	0f 43       	clr	r15		
    40c8:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 128, 10, BlinkRed, 3, 0);
    40cc:	43 12       	push.b	#0		;r3 As==00
    40ce:	70 12 03 00 	push.b	#3		;#0x0003
    40d2:	3c 40 7e 41 	mov	#16766,	r12	;#0x417e
    40d6:	3d 40 0a 00 	mov	#10,	r13	;#0x000a
    40da:	3e 40 80 00 	mov	#128,	r14	;#0x0080
    40de:	0f 43       	clr	r15		
    40e0:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 256, 2, BlinkRed, 4, 0);
    40e4:	43 12       	push.b	#0		;r3 As==00
    40e6:	70 12 04 00 	push.b	#4		;#0x0004
    40ea:	3c 40 7e 41 	mov	#16766,	r12	;#0x417e
    40ee:	2d 43       	mov	#2,	r13	;r3 As==10
    40f0:	3e 40 00 01 	mov	#256,	r14	;#0x0100
    40f4:	0f 43       	clr	r15		
    40f6:	b0 12 ce 42 	call	#0x42ce	

  RegisterTask (0, 1024, 10, BlinkYellow, 5, 0); 
    40fa:	43 12       	push.b	#0		;r3 As==00
    40fc:	70 12 05 00 	push.b	#5		;#0x0005
    4100:	3c 40 f6 41 	mov	#16886,	r12	;#0x41f6
    4104:	3d 40 0a 00 	mov	#10,	r13	;#0x000a
    4108:	3e 40 00 04 	mov	#1024,	r14	;#0x0400
    410c:	0f 43       	clr	r15		
    410e:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 512, 10, BlinkGreen, 6, 0);
    4112:	43 12       	push.b	#0		;r3 As==00
    4114:	70 12 06 00 	push.b	#6		;#0x0006
    4118:	3c 40 ba 41 	mov	#16826,	r12	;#0x41ba
    411c:	3d 40 0a 00 	mov	#10,	r13	;#0x000a
    4120:	3e 40 00 02 	mov	#512,	r14	;#0x0200
    4124:	0f 43       	clr	r15		
    4126:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 256, 5, BlinkRed, 7, 0);
    412a:	43 12       	push.b	#0		;r3 As==00
    412c:	70 12 07 00 	push.b	#7		;#0x0007
    4130:	3c 40 7e 41 	mov	#16766,	r12	;#0x417e
    4134:	3d 40 05 00 	mov	#5,	r13	;#0x0005
    4138:	3e 40 00 01 	mov	#256,	r14	;#0x0100
    413c:	0f 43       	clr	r15		
    413e:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 128, 5, BlinkRed, 8, 0);
    4142:	31 50 20 00 	add	#32,	r1	;#0x0020
    4146:	43 12       	push.b	#0		;r3 As==00
    4148:	70 12 08 00 	push.b	#8		;#0x0008
    414c:	3c 40 7e 41 	mov	#16766,	r12	;#0x417e
    4150:	3d 40 05 00 	mov	#5,	r13	;#0x0005
    4154:	3e 40 80 00 	mov	#128,	r14	;#0x0080
    4158:	0f 43       	clr	r15		
    415a:	b0 12 ce 42 	call	#0x42ce	
  RegisterTask (0, 256, 2, BlinkRed, 9, 0);
    415e:	43 12       	push.b	#0		;r3 As==00
    4160:	70 12 09 00 	push.b	#9		;#0x0009
    4164:	3c 40 7e 41 	mov	#16766,	r12	;#0x417e
    4168:	2d 43       	mov	#2,	r13	;r3 As==10
    416a:	3e 40 00 01 	mov	#256,	r14	;#0x0100
    416e:	0f 43       	clr	r15		
    4170:	b0 12 ce 42 	call	#0x42ce	
#endif


  _EINT();                        // Enable interrupts
    4174:	32 d2       	eint			
    4176:	31 52       	add	#8,	r1	;r2 As==11

  while(1) {
    EnterLowPowerMode3(); // idle task, set to low power mode 3 
    4178:	32 c0 d0 00 	bic	#208,	r2	;#0x00d0
    417c:	fd 3f       	jmp	$-4      	;abs 0x4178

0000417e <BlinkRed>:
  CountRealtimeDelay(ExecutionTime);
  SetLeds (GREEN, 0);
}

void BlinkRed (uint16_t ExecutionTime)
{
    417e:	0b 12       	push	r11		
    4180:	0b 4f       	mov	r15,	r11	
  SetLeds (RED, 1);
    4182:	5e 43       	mov.b	#1,	r14	;r3 As==01
    4184:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    4188:	b0 12 3c 42 	call	#0x423c	
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    418c:	0f 4b       	mov	r11,	r15	
    418e:	0f 5f       	rla	r15		
    4190:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    4192:	1d 42 70 01 	mov	&0x0170,r13	
    4196:	0e 43       	clr	r14		
    4198:	07 3c       	jmp	$+16     	;abs 0x41a8
  while (TicksPassed < Ticks) // continue until all ticks have passed
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    419a:	1c 42 70 01 	mov	&0x0170,r12	
    419e:	0d 9c       	cmp	r12,	r13	
    41a0:	fc 27       	jz	$-6      	;abs 0x419a
    {
      TicksPassed++; // increment ticks counter
    41a2:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    41a4:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    41a8:	0e 9f       	cmp	r15,	r14	
    41aa:	f7 2b       	jnc	$-16     	;abs 0x419a

void BlinkRed (uint16_t ExecutionTime)
{
  SetLeds (RED, 1);
  CountRealtimeDelay(ExecutionTime);
  SetLeds (RED, 0);
    41ac:	4e 43       	clr.b	r14		
    41ae:	7f 40 10 00 	mov.b	#16,	r15	;#0x0010
    41b2:	b0 12 3c 42 	call	#0x423c	
}
    41b6:	3b 41       	pop	r11		
    41b8:	30 41       	ret			

000041ba <BlinkGreen>:
  CountRealtimeDelay(ExecutionTime);
  SetLeds (YELLOW, 0);
}

void BlinkGreen (uint16_t ExecutionTime)
{
    41ba:	0b 12       	push	r11		
    41bc:	0b 4f       	mov	r15,	r11	
  SetLeds (GREEN, 1);
    41be:	5e 43       	mov.b	#1,	r14	;r3 As==01
    41c0:	7f 40 20 00 	mov.b	#32,	r15	;#0x0020
    41c4:	b0 12 3c 42 	call	#0x423c	
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    41c8:	0f 4b       	mov	r11,	r15	
    41ca:	0f 5f       	rla	r15		
    41cc:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    41ce:	1d 42 70 01 	mov	&0x0170,r13	
    41d2:	0e 43       	clr	r14		
    41d4:	07 3c       	jmp	$+16     	;abs 0x41e4
  while (TicksPassed < Ticks) // continue until all ticks have passed
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    41d6:	1c 42 70 01 	mov	&0x0170,r12	
    41da:	0d 9c       	cmp	r12,	r13	
    41dc:	fc 27       	jz	$-6      	;abs 0x41d6
    {
      TicksPassed++; // increment ticks counter
    41de:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    41e0:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    41e4:	0e 9f       	cmp	r15,	r14	
    41e6:	f7 2b       	jnc	$-16     	;abs 0x41d6

void BlinkGreen (uint16_t ExecutionTime)
{
  SetLeds (GREEN, 1);
  CountRealtimeDelay(ExecutionTime);
  SetLeds (GREEN, 0);
    41e8:	4e 43       	clr.b	r14		
    41ea:	7f 40 20 00 	mov.b	#32,	r15	;#0x0020
    41ee:	b0 12 3c 42 	call	#0x423c	
}
    41f2:	3b 41       	pop	r11		
    41f4:	30 41       	ret			

000041f6 <BlinkYellow>:
    }
  }
}

void BlinkYellow (uint16_t ExecutionTime)
{
    41f6:	0b 12       	push	r11		
    41f8:	0b 4f       	mov	r15,	r11	
  SetLeds (YELLOW, 1);
    41fa:	5e 43       	mov.b	#1,	r14	;r3 As==01
    41fc:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    4200:	b0 12 3c 42 	call	#0x423c	
void CountRealtimeDelay (uint16_t Ticks)
{
  uint16_t TicksPassed = 0;
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!
    4204:	0f 4b       	mov	r11,	r15	
    4206:	0f 5f       	rla	r15		
    4208:	0f 5f       	rla	r15		

  OldTAR = TAR; // store current value of TAR
    420a:	1d 42 70 01 	mov	&0x0170,r13	
    420e:	0e 43       	clr	r14		
    4210:	07 3c       	jmp	$+16     	;abs 0x4220
  while (TicksPassed < Ticks) // continue until all ticks have passed
  {
    if (OldTAR != TAR) // a new value of TAR exists, thus a tick has occured
    4212:	1c 42 70 01 	mov	&0x0170,r12	
    4216:	0d 9c       	cmp	r12,	r13	
    4218:	fc 27       	jz	$-6      	;abs 0x4212
    {
      TicksPassed++; // increment ticks counter
    421a:	1e 53       	inc	r14		
      OldTAR = TAR; // store new value of TAR as old value
    421c:	1d 42 70 01 	mov	&0x0170,r13	
  uint16_t OldTAR;

  Ticks *= 4; // multiply by 4, to get ms approximately!

  OldTAR = TAR; // store current value of TAR
  while (TicksPassed < Ticks) // continue until all ticks have passed
    4220:	0e 9f       	cmp	r15,	r14	
    4222:	f7 2b       	jnc	$-16     	;abs 0x4212

void BlinkYellow (uint16_t ExecutionTime)
{
  SetLeds (YELLOW, 1);
  CountRealtimeDelay(ExecutionTime);
  SetLeds (YELLOW, 0);
    4224:	4e 43       	clr.b	r14		
    4226:	7f 40 40 00 	mov.b	#64,	r15	;#0x0040
    422a:	b0 12 3c 42 	call	#0x423c	
}
    422e:	3b 41       	pop	r11		
    4230:	30 41       	ret			

00004232 <InitLeds>:
#include <iomacros.h>
#include "Led.h"

void InitLeds (uint8_t Colors)
{
  LEDDIR |= Colors;
    4232:	c2 df 32 00 	bis.b	r15,	&0x0032	
  LEDPIN = 0;
    4236:	c2 43 31 00 	mov.b	#0,	&0x0031	;r3 As==00
}
    423a:	30 41       	ret			

0000423c <SetLeds>:

void SetLeds (uint8_t Colors, uint8_t On)
{
  if (On) LEDPIN |= Colors;
    423c:	4e 93       	tst.b	r14		
    423e:	03 24       	jz	$+8      	;abs 0x4246
    4240:	c2 df 31 00 	bis.b	r15,	&0x0031	
    4244:	30 41       	ret			
  else    LEDPIN &= ~Colors;
    4246:	c2 cf 31 00 	bic.b	r15,	&0x0031	
    424a:	30 41       	ret			

0000424c <ToggleLeds>:
}

void ToggleLeds (uint8_t Colors)
{
  LEDPIN ^= Colors;
    424c:	c2 ef 31 00 	xor.b	r15,	&0x0031	
}
    4250:	30 41       	ret			

00004252 <InitClock>:

#define ACLOCK    32768  /* rate of the Aclock                               */

void InitClock (void)
{
	TACTL  = TASSEL0 + TACLR + ID0 + ID1 + TAIE; /* ACLK, clear TAR, set clock divider at 8 */
    4252:	b2 40 c6 01 	mov	#454,	&0x0160	;#0x01c6
    4256:	60 01 
	TACCR0   = 0;  /* start first interrupt right away     */
    4258:	82 43 72 01 	mov	#0,	&0x0172	;r3 As==00
	TACCTL0  = CCIE;            /* CCR0 interrupt enabled                        */
    425c:	b2 40 10 00 	mov	#16,	&0x0162	;#0x0010
    4260:	62 01 
	TACTL |= MC1;		    /* Start Timer_a in continious mode */  
    4262:	b2 d0 20 00 	bis	#32,	&0x0160	;#0x0020
    4266:	60 01 
}
    4268:	30 41       	ret			

0000426a <ContextSwitch>:
static uint8_t Contexts[NUMTASKS];
static uint8_t CurrentContext = 0;

void ContextSwitch()
{
	Contexts[CurrentContext] = LEDPIN; // store current context
    426a:	5f 42 00 11 	mov.b	&0x1100,r15	
    426e:	4e 4f       	mov.b	r15,	r14	
    4270:	de 42 31 00 	mov.b	&0x0031,4354(r14);0x1102(r14)
    4274:	02 11 
	CurrentContext++;
    4276:	5f 53       	inc.b	r15		
    4278:	c2 4f 00 11 	mov.b	r15,	&0x1100	
	// TODO set this to 0xFF for leds
	LEDPIN = 0; // disable all leds
    427c:	c2 43 31 00 	mov.b	#0,	&0x0031	;r3 As==00
}
    4280:	30 41       	ret			

00004282 <ResumeContext>:

void ResumeContext()
{
	CurrentContext--;
    4282:	5f 42 00 11 	mov.b	&0x1100,r15	
    4286:	7f 53       	add.b	#-1,	r15	;r3 As==11
    4288:	c2 4f 00 11 	mov.b	r15,	&0x1100	
	LEDPIN = Contexts[CurrentContext]; // resume context
    428c:	7f f3       	and.b	#-1,	r15	;r3 As==11
    428e:	3f 50 02 11 	add	#4354,	r15	;#0x1102
    4292:	e2 4f 31 00 	mov.b	@r15,	&0x0031	
}
    4296:	30 41       	ret			

00004298 <IntDisable>:

uint16_t IntDisable (void)
{
  uint16_t sw;
    // sw = r2
  asm volatile ("mov.w r2, %0\n\t" : "=r"(sw));
    4298:	0f 42       	mov	r2,	r15	
  _DINT();
    429a:	32 c2       	dint			
  return (sw);
}
    429c:	30 41       	ret			

0000429e <RestoreSW>:

void RestoreSW (uint16_t sw)
{
    // r2 = sw
  asm volatile ("mov.w %0, r2\n\t" :: "r"(sw));
    429e:	02 4f       	mov	r15,	r2	
}  
    42a0:	30 41       	ret			

000042a2 <InitTasks>:
 * Should be called with interrupt disabled.
 * The clock must be started elsewhere.
 */

void InitTasks (void)
{			
    42a2:	7e 40 09 00 	mov.b	#9,	r14	;#0x0009
  uint8_t i=NUMTASKS-1; 
  do { 
    Taskp t = &Tasks[i];
    42a6:	4f 4e       	mov.b	r14,	r15	
    42a8:	0f 5f       	rla	r15		
    42aa:	0f 5f       	rla	r15		
    42ac:	0f 5f       	rla	r15		
    42ae:	0f 5f       	rla	r15		
    42b0:	3f 50 12 11 	add	#4370,	r15	;#0x1112
    t->Flags = t->Activated = t->Invoked = 0;
    42b4:	cf 43 07 00 	mov.b	#0,	7(r15)	;r3 As==00, 0x0007(r15)
    42b8:	cf 43 06 00 	mov.b	#0,	6(r15)	;r3 As==00, 0x0006(r15)
    42bc:	5d 4f 06 00 	mov.b	6(r15),	r13	;0x0006(r15)
    42c0:	7d f3       	and.b	#-1,	r13	;r3 As==11
    42c2:	8f 4d 08 00 	mov	r13,	8(r15)	;0x0008(r15)
  } while (i--);
    42c6:	7e 53       	add.b	#-1,	r14	;r3 As==11
    42c8:	7e 93       	cmp.b	#-1,	r14	;r3 As==11
    42ca:	ed 23       	jnz	$-36     	;abs 0x42a6
}
    42cc:	30 41       	ret			

000042ce <RegisterTask>:
 * Each priority level has at most one task.
 */

uint8_t RegisterTask (uint16_t Phasing, uint16_t Period, uint16_t ExecutionTime,
                      void (*TaskFunc) (uint16_t), uint8_t Prio, uint8_t Flags)
{
    42ce:	0b 12       	push	r11		
    42d0:	0a 12       	push	r10		
    42d2:	09 12       	push	r9		
    42d4:	05 12       	push	r5		
    42d6:	05 41       	mov	r1,	r5	
    42d8:	35 50 0a 00 	add	#10,	r5	;#0x000a
    42dc:	6b 45       	mov.b	@r5,	r11	
    42de:	59 45 02 00 	mov.b	2(r5),	r9	;0x0002(r5)
  uint16_t sw;

  Phasing *= 4; // correct to get ms approximately
  Period *=4; // correct to get ms approximately

  if (Prio>=NUMTASKS) return (E_BOUNDS); // out of bounds
    42e2:	7b 90 0a 00 	cmp.b	#10,	r11	;#0x000a
    42e6:	02 28       	jnc	$+6      	;abs 0x42ec
    42e8:	5f 43       	mov.b	#1,	r15	;r3 As==01
    42ea:	2e 3c       	jmp	$+94     	;abs 0x4348
{
  uint8_t  rtc = E_SUCCESS;
  uint16_t sw;

  Phasing *= 4; // correct to get ms approximately
  Period *=4; // correct to get ms approximately
    42ec:	0e 5e       	rla	r14		
    42ee:	0e 5e       	rla	r14		

  if (Prio>=NUMTASKS) return (E_BOUNDS); // out of bounds
  if (Period == 0) return (E_WRONGPAR);
    42f0:	0e 93       	tst	r14		
    42f2:	03 20       	jnz	$+8      	;abs 0x42fa
    42f4:	7f 40 05 00 	mov.b	#5,	r15	;#0x0005
    42f8:	27 3c       	jmp	$+80     	;abs 0x4348

uint16_t IntDisable (void)
{
  uint16_t sw;
    // sw = r2
  asm volatile ("mov.w r2, %0\n\t" : "=r"(sw));
    42fa:	05 42       	mov	r2,	r5	
  _DINT();
    42fc:	32 c2       	dint			
  Period *=4; // correct to get ms approximately

  if (Prio>=NUMTASKS) return (E_BOUNDS); // out of bounds
  if (Period == 0) return (E_WRONGPAR);
  sw = IntDisable (); 
  Taskp t = &Tasks[Prio]; 
    42fe:	7b f3       	and.b	#-1,	r11	;r3 As==11
    4300:	0b 5b       	rla	r11		
    4302:	0b 5b       	rla	r11		
    4304:	0b 5b       	rla	r11		
    4306:	0b 5b       	rla	r11		
    4308:	3b 50 12 11 	add	#4370,	r11	;#0x1112
  if (t->Flags) rtc = E_BUSY; 
    430c:	1a 4b 08 00 	mov	8(r11),	r10	;0x0008(r11)
    4310:	0a 93       	tst	r10		
    4312:	02 24       	jz	$+6      	;abs 0x4318
    4314:	6f 43       	mov.b	#2,	r15	;r3 As==10
    4316:	17 3c       	jmp	$+48     	;abs 0x4346
                      void (*TaskFunc) (uint16_t), uint8_t Prio, uint8_t Flags)
{
  uint8_t  rtc = E_SUCCESS;
  uint16_t sw;

  Phasing *= 4; // correct to get ms approximately
    4318:	0f 5f       	rla	r15		
  if (Period == 0) return (E_WRONGPAR);
  sw = IntDisable (); 
  Taskp t = &Tasks[Prio]; 
  if (t->Flags) rtc = E_BUSY; 
  else {
    t->NextRelease = 0 + Phasing;
    431a:	0f 5f       	rla	r15		
    431c:	8b 4f 00 00 	mov	r15,	0(r11)	;0x0000(r11)
    t->Period    = Period; 
    4320:	8b 4e 04 00 	mov	r14,	4(r11)	;0x0004(r11)
    t->NextPendingDeadline = t->NextRelease + Period;
    4324:	2e 5b       	add	@r11,	r14	
    4326:	8b 4e 02 00 	mov	r14,	2(r11)	;0x0002(r11)
    t->Activated = t->Invoked = 0; 
    432a:	cb 4a 07 00 	mov.b	r10,	7(r11)	;0x0007(r11)
    432e:	cb 4a 06 00 	mov.b	r10,	6(r11)	;0x0006(r11)
    t->Taskf     = TaskFunc; 
    4332:	8b 4c 0c 00 	mov	r12,	12(r11)	;0x000c(r11)
    t->ExecutionTime = ExecutionTime;
    4336:	8b 4d 0a 00 	mov	r13,	10(r11)	;0x000a(r11)
    t->Flags     = Flags | TRIGGERED;
    433a:	79 d0 40 00 	bis.b	#64,	r9	;#0x0040
    433e:	79 f3       	and.b	#-1,	r9	;r3 As==11
    4340:	8b 49 08 00 	mov	r9,	8(r11)	;0x0008(r11)
    4344:	4f 4a       	mov.b	r10,	r15	
}

void RestoreSW (uint16_t sw)
{
    // r2 = sw
  asm volatile ("mov.w %0, r2\n\t" :: "r"(sw));
    4346:	02 45       	mov	r5,	r2	
    t->Flags     = Flags | TRIGGERED;

  }
  RestoreSW (sw);
  return (rtc);
}
    4348:	35 41       	pop	r5		
    434a:	39 41       	pop	r9		
    434c:	3a 41       	pop	r10		
    434e:	3b 41       	pop	r11		
    4350:	30 41       	ret			

00004352 <UnRegisterTask>:

uint8_t UnRegisterTask (uint8_t t)
{
  Tasks[t].Flags = 0;
    4352:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4354:	0f 5f       	rla	r15		
    4356:	1f 53       	inc	r15		
    4358:	0f 5f       	rla	r15		
    435a:	0f 5f       	rla	r15		
    435c:	0f 5f       	rla	r15		
    435e:	8f 43 12 11 	mov	#0,	4370(r15);r3 As==00, 0x1112(r15)
  return (E_SUCCESS);
}  
    4362:	4f 43       	clr.b	r15		
    4364:	30 41       	ret			

00004366 <gcd>:

  Use the Task data structure defined in 'Scheduler.h' to store information which can be used by the scheduler.

*/
// for calculating hyper period
int gcd(int a, int b) {
    4366:	0b 12       	push	r11		
    4368:	0a 12       	push	r10		
    436a:	09 12       	push	r9		
    436c:	09 4e       	mov	r14,	r9	
  if (b == 0) {
    436e:	0e 93       	tst	r14		
    4370:	06 24       	jz	$+14     	;abs 0x437e
    return a;
  }
  return gcd(b, a % b);
    4372:	0c 4f       	mov	r15,	r12	
    4374:	0a 4e       	mov	r14,	r10	
    4376:	b0 12 ac 46 	call	#0x46ac	
    437a:	0f 49       	mov	r9,	r15	
    437c:	f7 3f       	jmp	$-16     	;abs 0x436c
}
    437e:	39 41       	pop	r9		
    4380:	3a 41       	pop	r10		
    4382:	3b 41       	pop	r11		
    4384:	30 41       	ret			

00004386 <lcm>:

// for calculating hyper period
int lcm(int a, int b) {
    4386:	0b 12       	push	r11		
    4388:	0a 12       	push	r10		
    438a:	09 12       	push	r9		
    438c:	08 12       	push	r8		
    438e:	08 4e       	mov	r14,	r8	
    4390:	09 4e       	mov	r14,	r9	
    4392:	0a 4f       	mov	r15,	r10	
  Use the Task data structure defined in 'Scheduler.h' to store information which can be used by the scheduler.

*/
// for calculating hyper period
int gcd(int a, int b) {
  if (b == 0) {
    4394:	09 93       	tst	r9		
    4396:	07 24       	jz	$+16     	;abs 0x43a6
    return a;
  }
  return gcd(b, a % b);
    4398:	0c 4a       	mov	r10,	r12	
    439a:	0a 49       	mov	r9,	r10	
    439c:	b0 12 ac 46 	call	#0x46ac	
    43a0:	0a 49       	mov	r9,	r10	
    43a2:	09 4e       	mov	r14,	r9	
    43a4:	f7 3f       	jmp	$-16     	;abs 0x4394
    43a6:	02 12       	push	r2		
    43a8:	32 c2       	dint			
    43aa:	03 43       	nop			
    43ac:	82 48 32 01 	mov	r8,	&0x0132	
    43b0:	82 4f 38 01 	mov	r15,	&0x0138	
    43b4:	1c 42 3a 01 	mov	&0x013a,r12	
    43b8:	32 41       	pop	r2		
    43ba:	b0 12 ac 46 	call	#0x46ac	
}

// for calculating hyper period
int lcm(int a, int b) {
  return (a * b) / gcd(a, b);
}
    43be:	0f 4c       	mov	r12,	r15	
    43c0:	38 41       	pop	r8		
    43c2:	39 41       	pop	r9		
    43c4:	3a 41       	pop	r10		
    43c6:	3b 41       	pop	r11		
    43c8:	30 41       	ret			

000043ca <TimerIntrpt>:

interrupt (TIMERA0_VECTOR) TimerIntrpt (void)
{
    43ca:	0f 12       	push	r15		
    43cc:	0e 12       	push	r14		
    43ce:	0d 12       	push	r13		
    43d0:	0c 12       	push	r12		
  ContextSwitch();
    43d2:	b0 12 6a 42 	call	#0x426a	
  // uint16_t hyperperiod = 0;
  uint8_t i = 0;
  uint16_t oldNextInterruptTime = NextInterruptTime; // This is the current time when interrupt occurrs
    43d6:	1e 42 b2 11 	mov	&0x11b2,r14	
  // for (i = 0; i < NUMTASKS; i++) {
  //   Taskp t = &Tasks[i];
  //   hyperperiod = lcm(hyperperiod, t->Period);
  // }

  if (oldNextInterruptTime % (1024*4) == 0) {
    43da:	3e b0 ff 0f 	bit	#4095,	r14	;#0x0fff
    43de:	04 24       	jz	$+10     	;abs 0x43e8
    43e0:	3e 40 12 11 	mov	#4370,	r14	;#0x1112
// for calculating hyper period
int lcm(int a, int b) {
  return (a * b) / gcd(a, b);
}

interrupt (TIMERA0_VECTOR) TimerIntrpt (void)
    43e4:	0f 4e       	mov	r14,	r15	
    43e6:	14 3c       	jmp	$+42     	;abs 0x4410
    43e8:	3f 40 12 11 	mov	#4370,	r15	;#0x1112
  // }

  if (oldNextInterruptTime % (1024*4) == 0) {
    for (i = 0; i < NUMTASKS; i++) {
      Taskp t = &Tasks[i];
      t->NextRelease += t->Period;
    43ec:	9f 5f 04 00 	add	4(r15),	0(r15)	;0x0004(r15), 0x0000(r15)
    43f0:	00 00 
      if(oldNextInterruptTime != 0){
    43f2:	0e 93       	tst	r14		
    43f4:	03 24       	jz	$+8      	;abs 0x43fc
        t->NextPendingDeadline += t->Period;
    43f6:	9f 5f 04 00 	add	4(r15),	2(r15)	;0x0004(r15), 0x0002(r15)
    43fa:	02 00 
      }
      
      t->Activated++;
    43fc:	df 53 06 00 	inc.b	6(r15)		;0x0006(r15)
      t->FlagNextInterrupt = 0;
    4400:	cf 43 0f 00 	mov.b	#0,	15(r15)	;r3 As==00, 0x000f(r15)
    4404:	3f 50 10 00 	add	#16,	r15	;#0x0010
  //   Taskp t = &Tasks[i];
  //   hyperperiod = lcm(hyperperiod, t->Period);
  // }

  if (oldNextInterruptTime % (1024*4) == 0) {
    for (i = 0; i < NUMTASKS; i++) {
    4408:	3f 90 b2 11 	cmp	#4530,	r15	;#0x11b2
    440c:	ef 23       	jnz	$-32     	;abs 0x43ec
    440e:	e8 3f       	jmp	$-46     	;abs 0x43e0
    }
  }

  for (i = 0; i < NUMTASKS; i++) {
    Taskp t = &Tasks[i];
    if (t->FlagNextInterrupt == TT) {
    4410:	ef 92 0f 00 	cmp.b	#4,	15(r15)	;r2 As==10, 0x000f(r15)
    4414:	0a 20       	jnz	$+22     	;abs 0x442a
      t->NextRelease += t->Period;
    4416:	9f 5f 04 00 	add	4(r15),	0(r15)	;0x0004(r15), 0x0000(r15)
    441a:	00 00 
            t->NextPendingDeadline += t->Period;
    441c:	9f 5f 04 00 	add	4(r15),	2(r15)	;0x0004(r15), 0x0002(r15)
    4420:	02 00 
      t->Activated++;
    4422:	df 53 06 00 	inc.b	6(r15)		;0x0006(r15)
      t->FlagNextInterrupt = 0;
    4426:	cf 43 0f 00 	mov.b	#0,	15(r15)	;r3 As==00, 0x000f(r15)
    442a:	3f 50 10 00 	add	#16,	r15	;#0x0010
      t->Activated++;
      t->FlagNextInterrupt = 0;
    }
  }

  for (i = 0; i < NUMTASKS; i++) {
    442e:	3f 90 b2 11 	cmp	#4530,	r15	;#0x11b2
    4432:	ee 23       	jnz	$-34     	;abs 0x4410
      t->FlagNextInterrupt = 0;
    }
  }

  Taskp t = &Tasks[0];
  NextInterruptTime = t->NextRelease;
    4434:	1f 42 12 11 	mov	&0x1112,r15	
    4438:	3d 40 12 11 	mov	#4370,	r13	;#0x1112


  for (i = 0; i < NUMTASKS; i++) {
    Taskp t = &Tasks[i];
    DetermineNextInterruptTime(t->NextRelease);
    443c:	2c 4d       	mov	@r13,	r12	
    443e:	0c 9f       	cmp	r15,	r12	
    4440:	01 2c       	jc	$+4      	;abs 0x4444
    4442:	0f 4c       	mov	r12,	r15	
    4444:	3d 50 10 00 	add	#16,	r13	;#0x0010

  Taskp t = &Tasks[0];
  NextInterruptTime = t->NextRelease;


  for (i = 0; i < NUMTASKS; i++) {
    4448:	3d 90 b2 11 	cmp	#4530,	r13	;#0x11b2
    444c:	f7 23       	jnz	$-16     	;abs 0x443c
    444e:	82 4f b2 11 	mov	r15,	&0x11b2	
  }

  
  for (i = 0; i < NUMTASKS; i++) {
    Taskp t = &Tasks[i];
    if (t->NextRelease == NextInterruptTime) {
    4452:	2f 9e       	cmp	@r14,	r15	
    4454:	02 20       	jnz	$+6      	;abs 0x445a
      t->FlagNextInterrupt = TT;
    4456:	ee 42 0f 00 	mov.b	#4,	15(r14)	;r2 As==10, 0x000f(r14)
    445a:	3e 50 10 00 	add	#16,	r14	;#0x0010
    Taskp t = &Tasks[i];
    DetermineNextInterruptTime(t->NextRelease);
  }

  
  for (i = 0; i < NUMTASKS; i++) {
    445e:	3e 90 b2 11 	cmp	#4530,	r14	;#0x11b2
    4462:	f7 23       	jnz	$-16     	;abs 0x4452
      t->FlagNextInterrupt = TT;
    }
  }
 

  TACCR0 = NextInterruptTime;
    4464:	82 4f 72 01 	mov	r15,	&0x0172	

  CALL_SCHEDULER;
    4468:	3f 40 12 11 	mov	#4370,	r15	;#0x1112
    446c:	b0 12 e0 44 	call	#0x44e0	

  ResumeContext();
    4470:	b0 12 82 42 	call	#0x4282	
}
    4474:	3c 41       	pop	r12		
    4476:	3d 41       	pop	r13		
    4478:	3e 41       	pop	r14		
    447a:	3f 41       	pop	r15		
    447c:	00 13       	reti			

0000447e <Scheduler_P_FP>:
  /* ---------------------------------------------------------------- */

}

void Scheduler_P_FP (Task Tasks[])
{ 
    447e:	0b 12       	push	r11		
    4480:	0a 12       	push	r10		
    4482:	09 12       	push	r9		
    4484:	0a 4f       	mov	r15,	r10	
  /* ----------------------- INSERT CODE HERE ----------------------- */

  /* Super simple, single task example */

  uint8_t oldBP = BusyPrio; // Set BusyPrio as the priority of the currently running task (the one that was executing just before the scheduler is called)
    4486:	59 42 10 11 	mov.b	&0x1110,r9	

  for(BusyPrio = 0; BusyPrio < oldBP; BusyPrio++) {
    448a:	c2 43 10 11 	mov.b	#0,	&0x1110	;r3 As==00
    448e:	21 3c       	jmp	$+68     	;abs 0x44d2
    Taskp t = &Tasks[BusyPrio];
    4490:	5b 42 10 11 	mov.b	&0x1110,r11	
    4494:	7b f3       	and.b	#-1,	r11	;r3 As==11
    4496:	0b 5b       	rla	r11		
    4498:	0b 5b       	rla	r11		
    449a:	0b 5b       	rla	r11		
    449c:	0b 5b       	rla	r11		
    449e:	0b 5a       	add	r10,	r11	
    while ((t->Activated != t->Invoked) && (t->Flags & TRIGGERED))
    44a0:	0d 3c       	jmp	$+28     	;abs 0x44bc
    {
      _EINT(); 
    44a2:	32 d2       	eint			

static void ExecuteTask (Taskp t)
{
  /* ----------------------- INSERT CODE HERE ----------------------- */

  t->Invoked++;
    44a4:	5e 53       	inc.b	r14		
    44a6:	cb 4e 07 00 	mov.b	r14,	7(r11)	;0x0007(r11)
  t->Taskf(t->ExecutionTime); // execute task
    44aa:	1f 4b 0a 00 	mov	10(r11),r15	;0x000a(r11)
    44ae:	9b 12 0c 00 	call	12(r11)	;0x000c(r11)
    Taskp t = &Tasks[BusyPrio];
    while ((t->Activated != t->Invoked) && (t->Flags & TRIGGERED))
    {
      _EINT(); 
      ExecuteTask(t);
      _DINT();
    44b2:	32 c2       	dint			
      t->Activated = t->Invoked;
    44b4:	5f 4b 07 00 	mov.b	7(r11),	r15	;0x0007(r11)
    44b8:	cb 4f 06 00 	mov.b	r15,	6(r11)	;0x0006(r11)

  uint8_t oldBP = BusyPrio; // Set BusyPrio as the priority of the currently running task (the one that was executing just before the scheduler is called)

  for(BusyPrio = 0; BusyPrio < oldBP; BusyPrio++) {
    Taskp t = &Tasks[BusyPrio];
    while ((t->Activated != t->Invoked) && (t->Flags & TRIGGERED))
    44bc:	5e 4b 07 00 	mov.b	7(r11),	r14	;0x0007(r11)
    44c0:	cb 9e 06 00 	cmp.b	r14,	6(r11)	;0x0006(r11)
    44c4:	04 24       	jz	$+10     	;abs 0x44ce
    44c6:	bb b0 40 00 	bit	#64,	8(r11)	;#0x0040, 0x0008(r11)
    44ca:	08 00 
    44cc:	ea 23       	jnz	$-42     	;abs 0x44a2

  /* Super simple, single task example */

  uint8_t oldBP = BusyPrio; // Set BusyPrio as the priority of the currently running task (the one that was executing just before the scheduler is called)

  for(BusyPrio = 0; BusyPrio < oldBP; BusyPrio++) {
    44ce:	d2 53 10 11 	inc.b	&0x1110	
    44d2:	c2 99 10 11 	cmp.b	r9,	&0x1110	
    44d6:	dc 2b       	jnc	$-70     	;abs 0x4490
  //   ExecuteTask(t);
  // }
  /* End of example*/

  /* ---------------------------------------------------------------- */
}
    44d8:	39 41       	pop	r9		
    44da:	3a 41       	pop	r10		
    44dc:	3b 41       	pop	r11		
    44de:	30 41       	ret			

000044e0 <Scheduler_P_EDF>:
  t->Invoked++;
  t->Taskf(t->ExecutionTime); // execute task
}

void Scheduler_P_EDF (Task Tasks[])
{ 
    44e0:	0b 12       	push	r11		
    44e2:	0a 12       	push	r10		
    44e4:	09 12       	push	r9		
    44e6:	08 12       	push	r8		
    44e8:	07 12       	push	r7		
    44ea:	31 50 f6 ff 	add	#-10,	r1	;#0xfff6
    44ee:	0b 4f       	mov	r15,	r11	
  uint8_t oldBP = BusyPrio; // Set BusyPrio as the priority of the currently running task (the one that was executing just before the scheduler is called)
    44f0:	59 42 10 11 	mov.b	&0x1110,r9	
  uint8_t i = 0;
  uint8_t new_prio[10];
  uint8_t a = 0;
  uint8_t b = 0;
  for(i = 0; i < NUMTASKS; i++){
    new_prio[i] = i;
    44f4:	c1 43 00 00 	mov.b	#0,	0(r1)	;r3 As==00, 0x0000(r1)
    44f8:	d1 43 01 00 	mov.b	#1,	1(r1)	;r3 As==01, 0x0001(r1)
    44fc:	e1 43 02 00 	mov.b	#2,	2(r1)	;r3 As==10, 0x0002(r1)
    4500:	4e 43       	clr.b	r14		
    4502:	0a 3c       	jmp	$+22     	;abs 0x4518
      Taskp t = &Tasks[new_prio[i]];
      Taskp t1 = &Tasks[new_prio[i - 1]];
      a = new_prio[i];
      b = new_prio[i - 1];
      if(t->NextPendingDeadline < t1->NextPendingDeadline){
        new_prio[i] = b;
    4504:	e1 41 01 00 	mov.b	@r1,	1(r1)	;0x0001(r1)
        new_prio[i - 1] = a;
    4508:	c1 4d 00 00 	mov.b	r13,	0(r1)	;0x0000(r1)
  for(i = 0; i < NUMTASKS; i++){
    new_prio[i] = i;
  }
  uint8_t c = 0;

  for(c = 0; c < NUMTASKS; c++){
    450c:	5e 53       	inc.b	r14		
    450e:	7e 90 03 00 	cmp.b	#3,	r14	;#0x0003
    4512:	02 20       	jnz	$+6      	;abs 0x4518
    4514:	4e 43       	clr.b	r14		
    4516:	3d 3c       	jmp	$+124    	;abs 0x4592
    for(i = NUMTASKS - 1; i > 0; i--){
      Taskp t = &Tasks[new_prio[i]];
    4518:	5d 41 02 00 	mov.b	2(r1),	r13	;0x0002(r1)
    451c:	4f 4d       	mov.b	r13,	r15	
    451e:	0f 5f       	rla	r15		
    4520:	0f 5f       	rla	r15		
    4522:	0f 5f       	rla	r15		
    4524:	0f 5f       	rla	r15		
    4526:	0a 4b       	mov	r11,	r10	
    4528:	0a 5f       	add	r15,	r10	
      Taskp t1 = &Tasks[new_prio[i - 1]];
    452a:	5c 41 01 00 	mov.b	1(r1),	r12	;0x0001(r1)
    452e:	4f 4c       	mov.b	r12,	r15	
    4530:	0f 5f       	rla	r15		
    4532:	0f 5f       	rla	r15		
    4534:	0f 5f       	rla	r15		
    4536:	0f 5f       	rla	r15		
    4538:	0f 5b       	add	r11,	r15	
      a = new_prio[i];
      b = new_prio[i - 1];
      if(t->NextPendingDeadline < t1->NextPendingDeadline){
    453a:	1a 4a 02 00 	mov	2(r10),	r10	;0x0002(r10)
    453e:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4542:	0a 9f       	cmp	r15,	r10	
    4544:	04 2c       	jc	$+10     	;abs 0x454e
        new_prio[i] = b;
    4546:	c1 4c 02 00 	mov.b	r12,	2(r1)	;0x0002(r1)
        new_prio[i - 1] = a;
    454a:	c1 4d 01 00 	mov.b	r13,	1(r1)	;0x0001(r1)
  }
  uint8_t c = 0;

  for(c = 0; c < NUMTASKS; c++){
    for(i = NUMTASKS - 1; i > 0; i--){
      Taskp t = &Tasks[new_prio[i]];
    454e:	5d 41 01 00 	mov.b	1(r1),	r13	;0x0001(r1)
    4552:	4f 4d       	mov.b	r13,	r15	
    4554:	0f 5f       	rla	r15		
    4556:	0f 5f       	rla	r15		
    4558:	0f 5f       	rla	r15		
    455a:	0f 5f       	rla	r15		
    455c:	0c 4b       	mov	r11,	r12	
    455e:	0c 5f       	add	r15,	r12	
      Taskp t1 = &Tasks[new_prio[i - 1]];
    4560:	6f 41       	mov.b	@r1,	r15	
    4562:	0f 5f       	rla	r15		
    4564:	0f 5f       	rla	r15		
    4566:	0f 5f       	rla	r15		
    4568:	0f 5f       	rla	r15		
    456a:	0f 5b       	add	r11,	r15	
      a = new_prio[i];
      b = new_prio[i - 1];
      if(t->NextPendingDeadline < t1->NextPendingDeadline){
    456c:	1c 4c 02 00 	mov	2(r12),	r12	;0x0002(r12)
    4570:	1f 4f 02 00 	mov	2(r15),	r15	;0x0002(r15)
    4574:	0c 9f       	cmp	r15,	r12	
    4576:	c6 2b       	jnc	$-114    	;abs 0x4504
    4578:	c9 3f       	jmp	$-108    	;abs 0x450c
      // if(t1->Activated == t1->Invoked){
      //   new_prio[i] = b;
      //   new_prio[i - 1] = a;
      // }
      if(t->NextPendingDeadline == t1->NextPendingDeadline){
        if(t1->Period > t->Period){
    457a:	9d 9f 04 00 	cmp	4(r15),	4(r13)	;0x0004(r15), 0x0004(r13)
    457e:	04 00 
    4580:	04 2c       	jc	$+10     	;abs 0x458a
          new_prio[i] = b;
    4582:	e1 41 01 00 	mov.b	@r1,	1(r1)	;0x0001(r1)
          new_prio[i - 1] = a;
    4586:	c1 4c 00 00 	mov.b	r12,	0(r1)	;0x0000(r1)
        new_prio[i] = b;
        new_prio[i - 1] = a;
      }
    }
  }
  for(c = 0; c < NUMTASKS; c++){
    458a:	5e 53       	inc.b	r14		
    458c:	7e 90 03 00 	cmp.b	#3,	r14	;#0x0003
    4590:	35 24       	jz	$+108    	;abs 0x45fc
    for(i = NUMTASKS - 1; i > 0; i--){
      Taskp t = &Tasks[new_prio[i]];
    4592:	5c 41 02 00 	mov.b	2(r1),	r12	;0x0002(r1)
    4596:	4f 4c       	mov.b	r12,	r15	
    4598:	0f 5f       	rla	r15		
    459a:	0f 5f       	rla	r15		
    459c:	0f 5f       	rla	r15		
    459e:	0f 5f       	rla	r15		
    45a0:	0d 4b       	mov	r11,	r13	
    45a2:	0d 5f       	add	r15,	r13	
      Taskp t1 = &Tasks[new_prio[i - 1]];
    45a4:	5a 41 01 00 	mov.b	1(r1),	r10	;0x0001(r1)
    45a8:	4f 4a       	mov.b	r10,	r15	
    45aa:	0f 5f       	rla	r15		
    45ac:	0f 5f       	rla	r15		
    45ae:	0f 5f       	rla	r15		
    45b0:	0f 5f       	rla	r15		
    45b2:	0f 5b       	add	r11,	r15	
      b = new_prio[i - 1];
      // if(t1->Activated == t1->Invoked){
      //   new_prio[i] = b;
      //   new_prio[i - 1] = a;
      // }
      if(t->NextPendingDeadline == t1->NextPendingDeadline){
    45b4:	17 4d 02 00 	mov	2(r13),	r7	;0x0002(r13)
    45b8:	18 4f 02 00 	mov	2(r15),	r8	;0x0002(r15)
    45bc:	07 98       	cmp	r8,	r7	
    45be:	08 20       	jnz	$+18     	;abs 0x45d0
        if(t1->Period > t->Period){
    45c0:	9d 9f 04 00 	cmp	4(r15),	4(r13)	;0x0004(r15), 0x0004(r13)
    45c4:	04 00 
    45c6:	04 2c       	jc	$+10     	;abs 0x45d0
          new_prio[i] = b;
    45c8:	c1 4a 02 00 	mov.b	r10,	2(r1)	;0x0002(r1)
          new_prio[i - 1] = a;
    45cc:	c1 4c 01 00 	mov.b	r12,	1(r1)	;0x0001(r1)
      }
    }
  }
  for(c = 0; c < NUMTASKS; c++){
    for(i = NUMTASKS - 1; i > 0; i--){
      Taskp t = &Tasks[new_prio[i]];
    45d0:	5c 41 01 00 	mov.b	1(r1),	r12	;0x0001(r1)
    45d4:	4f 4c       	mov.b	r12,	r15	
    45d6:	0f 5f       	rla	r15		
    45d8:	0f 5f       	rla	r15		
    45da:	0f 5f       	rla	r15		
    45dc:	0f 5f       	rla	r15		
    45de:	0d 4b       	mov	r11,	r13	
    45e0:	0d 5f       	add	r15,	r13	
      Taskp t1 = &Tasks[new_prio[i - 1]];
    45e2:	6f 41       	mov.b	@r1,	r15	
    45e4:	0f 5f       	rla	r15		
    45e6:	0f 5f       	rla	r15		
    45e8:	0f 5f       	rla	r15		
    45ea:	0f 5f       	rla	r15		
    45ec:	0f 5b       	add	r11,	r15	
      b = new_prio[i - 1];
      // if(t1->Activated == t1->Invoked){
      //   new_prio[i] = b;
      //   new_prio[i - 1] = a;
      // }
      if(t->NextPendingDeadline == t1->NextPendingDeadline){
    45ee:	18 4d 02 00 	mov	2(r13),	r8	;0x0002(r13)
    45f2:	1a 4f 02 00 	mov	2(r15),	r10	;0x0002(r15)
    45f6:	08 9a       	cmp	r10,	r8	
    45f8:	c8 23       	jnz	$-110    	;abs 0x458a
    45fa:	bf 3f       	jmp	$-128    	;abs 0x457a
  //   }
  //     SetLeds(BROWN, 1);
  //     SetLeds(BROWN, 0);
  // }

  for(BusyPrio = 0; BusyPrio < oldBP; BusyPrio++) {
    45fc:	c2 43 10 11 	mov.b	#0,	&0x1110	;r3 As==00
    4600:	20 3c       	jmp	$+66     	;abs 0x4642
    Taskp t = &Tasks[new_prio[BusyPrio]];
    4602:	5f 42 10 11 	mov.b	&0x1110,r15	
    4606:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4608:	0f 51       	add	r1,	r15	
    460a:	6f 4f       	mov.b	@r15,	r15	
    460c:	0f 5f       	rla	r15		
    460e:	0f 5f       	rla	r15		
    4610:	0f 5f       	rla	r15		
    4612:	0f 5f       	rla	r15		
    4614:	0a 4b       	mov	r11,	r10	
    4616:	0a 5f       	add	r15,	r10	
    while ((t->Activated != t->Invoked) && (t->Flags & TRIGGERED))
    4618:	09 3c       	jmp	$+20     	;abs 0x462c
    { 
      _EINT(); 
    461a:	32 d2       	eint			
#include "Scheduler.h"
#include "Led.h"

static void ExecuteTask (Taskp t)
{
  t->Invoked++;
    461c:	5f 53       	inc.b	r15		
    461e:	ca 4f 07 00 	mov.b	r15,	7(r10)	;0x0007(r10)
  t->Taskf(t->ExecutionTime); // execute task
    4622:	1f 4a 0a 00 	mov	10(r10),r15	;0x000a(r10)
    4626:	9a 12 0c 00 	call	12(r10)	;0x000c(r10)
    Taskp t = &Tasks[new_prio[BusyPrio]];
    while ((t->Activated != t->Invoked) && (t->Flags & TRIGGERED))
    { 
      _EINT(); 
      ExecuteTask(t);
      _DINT();
    462a:	32 c2       	dint			
  //     SetLeds(BROWN, 0);
  // }

  for(BusyPrio = 0; BusyPrio < oldBP; BusyPrio++) {
    Taskp t = &Tasks[new_prio[BusyPrio]];
    while ((t->Activated != t->Invoked) && (t->Flags & TRIGGERED))
    462c:	5f 4a 07 00 	mov.b	7(r10),	r15	;0x0007(r10)
    4630:	ca 9f 06 00 	cmp.b	r15,	6(r10)	;0x0006(r10)
    4634:	04 24       	jz	$+10     	;abs 0x463e
    4636:	ba b0 40 00 	bit	#64,	8(r10)	;#0x0040, 0x0008(r10)
    463a:	08 00 
    463c:	ee 23       	jnz	$-34     	;abs 0x461a
  //   }
  //     SetLeds(BROWN, 1);
  //     SetLeds(BROWN, 0);
  // }

  for(BusyPrio = 0; BusyPrio < oldBP; BusyPrio++) {
    463e:	d2 53 10 11 	inc.b	&0x1110	
    4642:	c2 99 10 11 	cmp.b	r9,	&0x1110	
    4646:	dd 2b       	jnc	$-68     	;abs 0x4602
      ExecuteTask(t);
      _DINT();
    }
  }

}
    4648:	31 50 0a 00 	add	#10,	r1	;#0x000a
    464c:	37 41       	pop	r7		
    464e:	38 41       	pop	r8		
    4650:	39 41       	pop	r9		
    4652:	3a 41       	pop	r10		
    4654:	3b 41       	pop	r11		
    4656:	30 41       	ret			

00004658 <StartTracking>:
static uint16_t Totals[TT_MAX];
static uint8_t JobsExecuted;

void StartTracking(uint8_t index)
{
    StartTimes[index] = TAR;
    4658:	7f f3       	and.b	#-1,	r15	;r3 As==11
    465a:	0f 5f       	rla	r15		
    465c:	9f 42 70 01 	mov	&0x0170,4358(r15);0x1106(r15)
    4660:	06 11 
}
    4662:	30 41       	ret			

00004664 <StopTracking>:

void StopTracking(uint8_t index)
{
    Totals[index] += TAR - StartTimes[index];
    4664:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4666:	0f 5f       	rla	r15		
    4668:	1e 42 70 01 	mov	&0x0170,r14	
    466c:	1e 5f 0a 11 	add	4362(r15),r14	;0x110a(r15)
    4670:	1e 8f 06 11 	sub	4358(r15),r14	;0x1106(r15)
    4674:	8f 4e 0a 11 	mov	r14,	4362(r15);0x110a(r15)
}
    4678:	30 41       	ret			

0000467a <AddJobExecution>:

void AddJobExecution()
{
    JobsExecuted++;
    467a:	d2 53 0e 11 	inc.b	&0x110e	
}
    467e:	30 41       	ret			

00004680 <PrintResults>:

void PrintResults()
{
    P1OUT = Totals[TT_TIMER_INTERRUPT] & 0xFF;
    4680:	3e 40 0a 11 	mov	#4362,	r14	;#0x110a
    4684:	2d 4e       	mov	@r14,	r13	
    4686:	c2 4d 21 00 	mov.b	r13,	&0x0021	
    P2OUT = Totals[TT_TIMER_INTERRUPT] >> 8;
    468a:	3f 4e       	mov	@r14+,	r15	
    468c:	0f 4d       	mov	r13,	r15	
    468e:	8f 10       	swpb	r15		
    4690:	7f f3       	and.b	#-1,	r15	;r3 As==11
    4692:	c2 4f 29 00 	mov.b	r15,	&0x0029	

    P3OUT = Totals[TT_SCHEDULER] & 0xFF;
    4696:	2f 4e       	mov	@r14,	r15	
    4698:	c2 4f 19 00 	mov.b	r15,	&0x0019	
    P4OUT = Totals[TT_SCHEDULER] >> 8;
    469c:	8f 10       	swpb	r15		
    469e:	7f f3       	and.b	#-1,	r15	;r3 As==11
    46a0:	c2 4f 1d 00 	mov.b	r15,	&0x001d	

    P6OUT = JobsExecuted;
    46a4:	d2 42 0e 11 	mov.b	&0x110e,&0x0035	
    46a8:	35 00 
    46aa:	30 41       	ret			

000046ac <__divmodhi4>:
    46ac:	0d 43       	clr	r13		
    46ae:	3c b0 00 80 	bit	#-32768,r12	;#0x8000
    46b2:	03 28       	jnc	$+8      	;abs 0x46ba
    46b4:	3c e3       	inv	r12		
    46b6:	1c 53       	inc	r12		
    46b8:	2d d2       	bis	#4,	r13	;r2 As==10
    46ba:	3a b0 00 80 	bit	#-32768,r10	;#0x8000
    46be:	03 28       	jnc	$+8      	;abs 0x46c6
    46c0:	3a e3       	inv	r10		
    46c2:	1a 53       	inc	r10		
    46c4:	3d d2       	bis	#8,	r13	;r2 As==11
    46c6:	b0 12 e2 46 	call	#0x46e2	
    46ca:	0d 10       	rrc	r13		
    46cc:	2d b2       	bit	#4,	r13	;r2 As==10
    46ce:	04 28       	jnc	$+10     	;abs 0x46d8
    46d0:	3e e3       	inv	r14		
    46d2:	1e 53       	inc	r14		
    46d4:	3c e3       	inv	r12		
    46d6:	1c 53       	inc	r12		
    46d8:	3d b2       	bit	#8,	r13	;r2 As==11
    46da:	02 28       	jnc	$+6      	;abs 0x46e0
    46dc:	3c e3       	inv	r12		
    46de:	1c 53       	inc	r12		
    46e0:	30 41       	ret			

000046e2 <__udivmodhi4>:
    46e2:	0e ee       	xor	r14,	r14	
    46e4:	3b 40 11 00 	mov	#17,	r11	;#0x0011
    46e8:	05 3c       	jmp	$+12     	;abs 0x46f4
    46ea:	0d 10       	rrc	r13		
    46ec:	0e 6e       	rlc	r14		
    46ee:	0e 9a       	cmp	r10,	r14	
    46f0:	01 28       	jnc	$+4      	;abs 0x46f4
    46f2:	0e 8a       	sub	r10,	r14	
    46f4:	0c 6c       	rlc	r12		
    46f6:	0d 6d       	rlc	r13		
    46f8:	1b 83       	dec	r11		
    46fa:	f7 23       	jnz	$-16     	;abs 0x46ea
    46fc:	30 41       	ret			

Disassembly of section .vectors:

0000ffe0 <InterruptVectors>:
    ffe0:	30 40 30 40 30 40 30 40 30 40 30 40 ca 43 30 40     0@0@0@0@0@0@.C0@
    fff0:	30 40 30 40 30 40 30 40 30 40 30 40 30 40 00 40     0@0@0@0@0@0@0@.@
